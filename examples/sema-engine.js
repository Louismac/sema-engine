/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	//CommonJS2 Comment
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	//AMD Comment
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	//CommonJS Comment
	else if(typeof exports === 'object')
		exports["sema-engine"] = factory();
	//Root Comment
	else
		root["sema-engine"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/assertThisInitialized.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/asyncToGenerator.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ \"./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/construct.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ ((module) => {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/inherits.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/isNativeFunction.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/setPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/typeof.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeFunction = __webpack_require__(/*! ./isNativeFunction */ \"./node_modules/@babel/runtime/helpers/isNativeFunction.js\");\n\nvar construct = __webpack_require__(/*! ./construct */ \"./node_modules/@babel/runtime/helpers/construct.js\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/helpers/wrapNativeSuper.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\n\n//# sourceURL=webpack://sema-engine/./node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "./src/engine/audioEngine.js":
/*!***********************************!*\
  !*** ./src/engine/audioEngine.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"), __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"), __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"), __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"), __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"), __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"), __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"), __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\"), __webpack_require__(/*! ./ringbuf.js */ \"./src/engine/ringbuf.js\"), __webpack_require__(/*! ./maximilian.util.js */ \"./src/engine/maximilian.util.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _regenerator, _asyncToGenerator2, _createClass2, _classCallCheck2, _inherits2, _possibleConstructorReturn2, _getPrototypeOf2, _wrapNativeSuper2, _ringbuf, _maximilianUtil) {\n  \"use strict\";\n\n  var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.AudioEngine = void 0;\n  _regenerator = _interopRequireDefault(_regenerator);\n  _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator2);\n  _createClass2 = _interopRequireDefault(_createClass2);\n  _classCallCheck2 = _interopRequireDefault(_classCallCheck2);\n  _inherits2 = _interopRequireDefault(_inherits2);\n  _possibleConstructorReturn2 = _interopRequireDefault(_possibleConstructorReturn2);\n  _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf2);\n  _wrapNativeSuper2 = _interopRequireDefault(_wrapNativeSuper2);\n  _ringbuf = _interopRequireDefault(_ringbuf);\n\n  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\n  function _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n  // import {\n  //   kuramotoNetClock\n  // } from './interfaces/clockInterface.js';\n  // import {\n  //   PubSub\n  // } from './messaging/pubSub.js';\n  // import {\n  //   PeerStreaming\n  // } from '../interfaces/peerStreaming.js';\n  // import {\n  //   copyToPasteBuffer\n  // } from '../utils/pasteBuffer.js';\n\n  /**\n   * The CustomMaxiNode is a class that extends AudioWorkletNode\n   * to hold an Custom Audio Worklet Processor and connect to Web Audio graph\n   * @class CustomMaxiNode\n   * @extends AudioWorkletNode\n   */\n  // if(true){\n  var CustomMaxiNode = /*#__PURE__*/function (_AudioWorkletNode) {\n    (0, _inherits2[\"default\"])(CustomMaxiNode, _AudioWorkletNode);\n\n    var _super = _createSuper(CustomMaxiNode);\n\n    function CustomMaxiNode(audioContext, processorName) {\n      (0, _classCallCheck2[\"default\"])(this, CustomMaxiNode);\n      // super(audioContext, processorName);\n      console.log();\n      var options = {\n        numberOfInputs: 1,\n        numberOfOutputs: 1,\n        outputChannelCount: [audioContext.destination.maxChannelCount]\n      };\n      return _super.call(this, audioContext, processorName, options);\n    }\n\n    return CustomMaxiNode;\n  }( /*#__PURE__*/(0, _wrapNativeSuper2[\"default\"])(AudioWorkletNode)); // }\n\n  /**\n   * The AudioEngine is a singleton class that encapsulates the AudioContext\n   * and all WASM and Maximilian -powered Audio Worklet Processor\n   * @class AudioEngine\n   */\n\n\n  var AudioEngine = /*#__PURE__*/function () {\n    /**\n     * @constructor\n     */\n    function AudioEngine() {\n      (0, _classCallCheck2[\"default\"])(this, AudioEngine);\n\n      if (AudioEngine.instance) {\n        return AudioEngine.instance; // Singleton pattern\n      }\n\n      AudioEngine.instance = this; // Hash of on-demand analysers (e.g. spectrogram, oscilloscope)\n      // NOTE: analysers from localStorage are loaded from local Storage before user-started audioContext init\n\n      this.analysers = {}; //shared array buffers for sharing client side data to the audio engine- e.g. mouse coords\n\n      this.sharedArrayBuffers = {}; // MOVE THIS TO AN UP LAYER IN SEMA\n      // Sema's Publish-Subscribe pattern object with 'lowercase-lowercase' format convention for subscription topic\n      // this.messaging = new PubSub();\n      // this.messaging.subscribe('eval-dsp', e => this.evalDSP(e));\n      // this.messaging.subscribe('stop-audio', e => this.stop());\n      // this.messaging.subscribe('load-sample', (name, url) =>\n      //   this.loadSample(name, url)\n      // );\n      // this.messaging.subscribe('model-output-data', e =>\n      //   this.onMessagingEventHandler(e)\n      // );\n      // this.messaging.subscribe('clock-phase', e =>\n      //   this.onMessagingEventHandler(e)\n      // );\n      // this.messaging.subscribe('model-send-buffer', e =>\n      //   this.onMessagingEventHandler(e)\n      // );\n      // this.messaging.subscribe('add-engine-analyser', e =>\n      //   this.createAnalyser(e)\n      // );\n      // this.messaging.subscribe('remove-engine-analyser', e =>\n      //   this.removeAnalyser(e)\n      // );\n      // this.messaging.subscribe('mouse-xy', e => {\n      //   if (this.sharedArrayBuffers.mxy) {\n      //     this.sharedArrayBuffers.mxy.rb.push(e);\n      //   }\n      // });\n      // this.messaging.subscribe('osc', e => console.log(`DEBUG:AudioEngine:OSC: ${e}`));\n      //temporarily disabled for now\n      // this.kuraClock = new kuramotoNetClock();\n      //temporarily disabled for now\n      // this.peerNet = new PeerStreaming();\n      //the message has incoming data from other peers\n      // this.messaging.subscribe('peermsg', (e) => {\n      //   e.ttype = 'NET';\n      //   e.peermsg = 1;\n      //   this.onMessagingEventHandler(e);\n      // });\n      // this.messaging.subscribe('peerinfo-request', (e) => {\n      //   console.log(this.peerNet.peerID);\n      //   copyToPasteBuffer(this.peerNet.peerID);\n      // });\n    }\n    /**\n     * Handler of audio worklet processor events\n     * @onProcessorMessageEventHandler\n     */\n\n\n    (0, _createClass2[\"default\"])(AudioEngine, [{\n      key: \"onProcessorMessageEventHandler\",\n      value: function onProcessorMessageEventHandler(event) {\n        if (event != undefined && event.data != undefined) {\n          // console.log('DEBUG:AudioEngine:processorMessageHandler:');\n          // console.log(event);\n          if (event.data.rq != undefined && event.data.rq === \"send\") {\n            switch (event.data.ttype) {\n              case \"ML\":\n                // Stream generated by 'toJS' live code instruction — e.g. {10,0,{1}sin}toJS;\n                // publishes to model/JS editor, which posts to ml.worker\n                this.messaging.publish(\"model-input-data\", {\n                  type: \"model-input-data\",\n                  value: event.data.value,\n                  ch: event.data.ch\n                });\n                break;\n\n              case \"NET\":\n                this.peerNet.send(event.data.ch[0], event.data.value, event.data.ch[1]);\n                break;\n            }\n          } else if (event.data.rq && event.data.rq === \"buf\") {\n            console.log(\"buf\", event.data);\n\n            switch (event.data.ttype) {\n              case \"ML\":\n                this.messaging.publish(\"model-input-buffer\", {\n                  type: \"model-input-buffer\",\n                  value: event.data.value,\n                  channelID: event.data.channelID,\n                  //channel ID\n                  blocksize: event.data.blocksize\n                });\n                break;\n            }\n          } else if (event.data === \"giveMeSomeSamples\") {} else if (event.data.phase != undefined) {// console.log('DEBUG:AudioEngine:phase:');\n            // console.log(event.data.phase);\n            // this.kuraClock.broadcastPhase(event.data.phase); // TODO Refactor p to phase\n          } // else if (event.data.rq != undefined && event.data.rq === 'receive') {\n          //   switch (event.data.ttype) {\n          //     case 'ML':\n          //       // Stream generated by 'fromJS' live code instruction – e.g. {{10,1}fromJS}saw\n          //       // publishes to model/JS editor, which posts to ml.worker\n          //       this.messaging.publish('model-output-data-request', {\n          //         type: 'model-output-data-request',\n          //         value: event.data.value,\n          //         channel: event.data.ch\n          //       });\n          //       break;\n          //     case 'NET':\n          //       break;\n          //   }\n          // }\n\n        }\n      }\n      /**\n       * Handler of the Pub/Sub message events\n       * whose topics are subscribed to in the audio engine constructor\n       * @onMessagingEventHandler\n       */\n\n    }, {\n      key: \"onMessagingEventHandler\",\n      value: function onMessagingEventHandler(event) {\n        if (event !== undefined) {\n          // Receive notification from 'model-output-data' topic\n          console.log(\"DEBUG:AudioEngine:onMessagingEventHandler:\");\n          console.log(event);\n          this.audioWorkletNode.port.postMessage(event);\n        }\n      }\n      /**\n       * Creates a WAAPI analyser node\n       * @todo configuration object as argumen\n       * @createAnalyser\n       */\n\n    }, {\n      key: \"createAnalyser\",\n      value: function createAnalyser(event) {\n        // If Analyser creation happens after AudioContext intialization, create and connect WAAPI analyser\n        if (this.audioContext !== undefined && event !== undefined) {\n          var analyser = this.audioContext.createAnalyser();\n          analyser.smoothingTimeConstant = 0.25;\n          analyser.fftSize = 256; // default 2048;\n\n          analyser.minDecibels = -90; // default\n\n          analyser.maxDecibels = -0; // default -10; max 0\n\n          this.connectAnalyser(analyser, event.id); // @todo Move out\n          // Other if AudioContext is NOT created yet (after app load, before splashScreen click)\n        } else if (this.audioContext === undefined) {\n          this.analysers[event.id] = {};\n        }\n      }\n      /**\n       * Polls data from connected WAAPI analyser return structured object with data and time data in arrays\n       * @param {*} analyser\n       */\n\n    }, {\n      key: \"pollAnalyserData\",\n      value: function pollAnalyserData(analyser) {\n        if (analyser !== undefined) {\n          var timeDataArray = new Uint8Array(analyser.fftSize); // Uint8Array should be the same length as the fftSize\n\n          var frequencyDataArray = new Uint8Array(analyser.fftSize);\n          analyser.getByteTimeDomainData(timeDataArray);\n          analyser.getByteFrequencyData(frequencyDataArray);\n          return {\n            smoothingTimeConstant: analyser.smoothingTimeConstant,\n            fftSize: analyser.fftSize,\n            frequencyDataArray: frequencyDataArray,\n            timeDataArray: timeDataArray\n          };\n        }\n      }\n      /**\n       * Connects WAAPI analyser node to the main audio worklet for visualisation.\n       * @connectAnalyser\n       */\n\n    }, {\n      key: \"connectAnalyser\",\n      value: function connectAnalyser(analyser, name) {\n        var _this = this;\n\n        if (this.audioWorkletNode !== undefined) {\n          this.audioWorkletNode.connect(analyser);\n          var analyserFrameId;\n          var analyserData;\n          /**\n           * Creates requestAnimationFrame loop for polling data and publishing\n           * Returns Analyser Frame ID for adding to Analysers hash and cancelling animation frame\n           */\n\n          var analyserPollingLoop = function analyserPollingLoop() {\n            analyserData = _this.pollAnalyserData(analyser);\n\n            _this.messaging.publish(\"analyser-data\", analyserData);\n\n            var analyserFrameId = requestAnimationFrame(analyserPollingLoop);\n            _this.analysers[name] = {\n              analyser: analyser,\n              analyserFrameId: analyserFrameId\n            };\n            return analyserFrameId;\n          }; // analyserFrameId = analyserPollingLoop;\n\n\n          analyserPollingLoop();\n        }\n      }\n    }, {\n      key: \"connectAnalysers\",\n      value: function connectAnalysers() {\n        var _this2 = this;\n\n        Object.keys(this.analysers).map(function (id) {\n          return _this2.createAnalyser({\n            id: id\n          });\n        });\n      }\n      /**\n       * Removes a WAAPI analyser node, disconnects graph, cancels animation frame, deletes from hash\n       * @removeAnalyser\n       */\n\n    }, {\n      key: \"removeAnalyser\",\n      value: function removeAnalyser(event) {\n        if (this.audioContext !== undefined && this.audioWorkletNode !== undefined) {\n          var analyser = this.analysers[event.id];\n\n          if (analyser !== undefined) {\n            cancelAnimationFrame(this.analysers[event.id].analyserFrameId);\n            delete this.analysers[event.id]; // this.audioWorkletNode.disconnect(analyser);\n          }\n        }\n      } //make a shared array buffer for communicating with the audio engine\n\n    }, {\n      key: \"createSharedArrayBuffer\",\n      value: function createSharedArrayBuffer(chID, ttype, blocksize) {\n        var sab = _ringbuf[\"default\"].getStorageForCapacity(32 * blocksize, Float64Array);\n\n        var ringbuf = new _ringbuf[\"default\"](sab, Float64Array);\n        this.audioWorkletNode.port.postMessage({\n          func: \"sab\",\n          value: sab,\n          ttype: ttype,\n          channelID: chID,\n          blocksize: blocksize\n        });\n        this.sharedArrayBuffers[chID] = {\n          sab: sab,\n          rb: ringbuf\n        };\n        console.log(this.sharedArrayBuffers);\n      }\n      /**\n       * Initialises audio context and sets worklet processor code\n       * @play\n       */\n\n    }, {\n      key: \"init\",\n      value: function () {\n        var _init = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(audioWorkletURL\n        /*numClockPeers*/\n        ) {\n          return _regenerator[\"default\"].wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  // AudioContext needs lazy loading to workaround the Chrome warning\n                  // Audio Engine first play() call, triggered by user, prevents the warning\n                  // by setting this.audioContext = new AudioContext();\n                  this.audioContext;\n                  this.audioWorkletProcessorName = \"maxi-processor\";\n                  this.audioWorkletUrl = audioWorkletURL;\n                  this.samplesLoaded = false;\n\n                  if (!(this.audioContext === undefined)) {\n                    _context.next = 13;\n                    break;\n                  }\n\n                  this.audioContext = new AudioContext({\n                    // create audio context with latency optimally configured for playback\n                    latencyHint: \"playback\" // latencyHint: 32/44100,  //this doesn't work below 512 on chrome (?)\n                    // sampleRate: 44100\n\n                  });\n                  this.audioContext.destination.channelInterpretation = \"discrete\";\n                  this.audioContext.destination.channelCountMode = \"explicit\";\n                  this.audioContext.destination.channelCount = this.audioContext.destination.maxChannelCount; // console.log(this.audioContext.destination);\n\n                  _context.next = 11;\n                  return this.loadWorkletProcessorCode();\n\n                case 11:\n                  // Connect the worklet node to the audio graph\n                  this.audioWorkletNode.connect(this.audioContext.destination); // this.audioWorkletNode.channelInterpretation = 'discrete';\n                  // this.audioWorkletNode.channelCountMode = 'explicit';\n                  // this.audioWorkletNode.channelCount = this.audioContext.destination.maxChannelCount;\n                  // this.connectMediaStream();\n                  // this.connectAnalysers(); // Connect Analysers loaded from the store\n                  // this.loadImportedSamples();\n                  // No need to inject the callback here, messaging is built in KuraClock\n                  // this.kuraClock = new kuramotoNetClock((phase, idx) => {\n                  //   // console.log( `DEBUG:AudioEngine:sendPeersMyClockPhase:phase:${phase}:id:${idx}`);\n                  //   // This requires an initialised audio worklet\n                  //   this.audioWorkletNode.port.postMessage({ phase: phase, i: idx });\n                  // });\n                  //temporarily disabled\n                  // if (this.kuraClock.connected()) {\n                  // \tthis.kuraClock.queryPeers(async numClockPeers => {\n                  // \t\tconsole.log(`DEBUG:AudioEngine:init:numClockPeers: ${numClockPeers}`);\n                  // \t});\n                  // }\n\n                  this.createSharedArrayBuffer(\"mxy\", \"mouseXY\", 2);\n\n                case 13:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function init(_x) {\n          return _init.apply(this, arguments);\n        }\n\n        return init;\n      }()\n      /**\n       * Initialises audio context and sets worklet processor code\n       * or re-starts audio playback by stopping and running the latest Audio Worklet Processor code\n       * @play\n       */\n\n    }, {\n      key: \"play\",\n      value: function play() {\n        if (this.audioContext !== undefined) {\n          if (this.audioContext.state !== \"suspended\") {\n            this.stop();\n            return false;\n          } else {\n            this.audioContext.resume();\n            return true;\n          }\n        }\n      }\n      /**\n       * Suspends AudioContext (Pause)\n       * @stop\n       */\n\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        if (this.audioWorkletNode !== undefined) {\n          this.audioContext.suspend();\n        }\n      }\n      /**\n       * Stops audio by disconnecting AudioNode with AudioWorkletProcessor code\n       * from Web Audio graph TODO Investigate when it is best to just STOP the graph exectution\n       * @stop\n       */\n\n    }, {\n      key: \"stopAndRelease\",\n      value: function stopAndRelease() {\n        if (this.audioWorkletNode !== undefined) {\n          this.audioWorkletNode.disconnect(this.audioContext.destination);\n          this.audioWorkletNode = undefined;\n        }\n      }\n    }, {\n      key: \"more\",\n      value: function more(gain) {\n        if (this.audioWorkletNode !== undefined) {\n          var gainParam = this.audioWorkletNode.parameters.get(gain);\n          gainParam.value += 0.5;\n          console.log(gain + \": \" + gainParam.value); // DEBUG\n\n          return true;\n        } else return false;\n      }\n    }, {\n      key: \"less\",\n      value: function less(gain) {\n        if (this.audioWorkletNode !== undefined) {\n          var gainParam = this.audioWorkletNode.parameters.get(gain);\n          gainParam.value -= 0.5;\n          console.log(gain + \": \" + gainParam.value); // DEBUG\n\n          return true;\n        } else return false;\n      }\n    }, {\n      key: \"eval\",\n      value: function _eval(dspFunction) {\n        // console.log('DEBUG:AudioEngine:evalDSP:');\n        // console.log(dspFunction);\n        if (this.audioWorkletNode !== undefined) {\n          if (this.audioContext.state === \"suspended\") {\n            this.audioContext.resume();\n          }\n\n          this.audioWorkletNode.port.postMessage({\n            eval: 1,\n            setup: dspFunction.setup,\n            loop: dspFunction.loop\n          });\n          return true;\n        } else return false;\n      }\n    }, {\n      key: \"sendClockPhase\",\n      value: function sendClockPhase(phase, idx) {\n        if (this.audioWorkletNode !== undefined) {\n          this.audioWorkletNode.port.postMessage({\n            phase: phase,\n            i: idx\n          });\n        }\n      }\n    }, {\n      key: \"onAudioInputInit\",\n      value: function onAudioInputInit(stream) {\n        // console.log('DEBUG:AudioEngine: Audio Input init');\n        var mediaStreamSource = this.audioContext.createMediaStreamSource(stream);\n        mediaStreamSource.connect(this.audioWorkletNode);\n      }\n    }, {\n      key: \"onAudioInputFail\",\n      value: function onAudioInputFail(error) {\n        console.log(\"DEBUG:AudioEngine:AudioInputFail: \".concat(error.message, \" \").concat(error.name));\n      }\n      /**\n       * Sets up an AudioIn WAAPI sub-graph\n       * @connectMediaStreamSourceInput\n       */\n\n    }, {\n      key: \"connectMediaStream\",\n      value: function () {\n        var _connectMediaStream = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n          var _this3 = this;\n\n          var constraints;\n          return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  constraints = window.constraints = {\n                    audio: true,\n                    video: false\n                  };\n                  navigator.mediaDevices.getUserMedia(constraints).then(function (s) {\n                    return _this3.onAudioInputInit(s);\n                  })[\"catch\"](this.onAudioInputFail);\n\n                case 2:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function connectMediaStream() {\n          return _connectMediaStream.apply(this, arguments);\n        }\n\n        return connectMediaStream;\n      }()\n      /**\n       * Loads audioWorklet processor code into a worklet,\n       * setups up all handlers (errors, async messaging, etc),\n       * connects the worklet processor to the WAAPI graph\n       */\n\n    }, {\n      key: \"loadWorkletProcessorCode\",\n      value: function () {\n        var _loadWorkletProcessorCode = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3() {\n          var _this4 = this;\n\n          return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (!(this.audioContext !== undefined)) {\n                    _context3.next = 25;\n                    break;\n                  }\n\n                  _context3.prev = 1;\n                  _context3.next = 4;\n                  return this.audioContext.audioWorklet.addModule(this.audioWorkletUrl);\n\n                case 4:\n                  _context3.next = 10;\n                  break;\n\n                case 6:\n                  _context3.prev = 6;\n                  _context3.t0 = _context3[\"catch\"](1);\n                  console.error(\"ERROR: AudioEngine:loadWorkletProcessorCode: AudioWorklet not supported in this browser: \", _context3.t0.message);\n                  return _context3.abrupt(\"return\", false);\n\n                case 10:\n                  _context3.prev = 10;\n                  // Custom node constructor with required parameters\n                  this.audioWorkletNode = new CustomMaxiNode(this.audioContext, this.audioWorkletProcessorName); // All possible error event handlers subscribed\n\n                  this.audioWorkletNode.onprocessorerror = function (event) {\n                    // Errors from the processor\n                    console.log(\"DEBUG:AudioEngine:loadWorkletProcessorCode: MaxiProcessor Error detected\");\n                  };\n\n                  this.audioWorkletNode.port.onmessageerror = function (event) {\n                    //  error from the processor port\n                    console.log(\"DEBUG:AudioEngine:loadWorkletProcessorCode: Error message from port: \" + event.data);\n                  }; // State changes in the audio worklet processor\n\n\n                  this.audioWorkletNode.onprocessorstatechange = function (event) {\n                    console.log(\"DEBUG:AudioEngine:loadWorkletProcessorCode: MaxiProcessor state change detected: \" + audioWorkletNode.processorState);\n                  }; // Worklet Processor message handler\n\n\n                  this.audioWorkletNode.port.onmessage = function (event) {\n                    _this4.onProcessorMessageEventHandler(event);\n                  };\n\n                  return _context3.abrupt(\"return\", true);\n\n                case 19:\n                  _context3.prev = 19;\n                  _context3.t1 = _context3[\"catch\"](10);\n                  console.error(\"ERROR: AudioEngine:loadWorkletProcessorCode: Custom AudioWorklet node creation: \", _context3.t1.message);\n                  return _context3.abrupt(\"return\", false);\n\n                case 23:\n                  _context3.next = 26;\n                  break;\n\n                case 25:\n                  return _context3.abrupt(\"return\", false);\n\n                case 26:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this, [[1, 6], [10, 19]]);\n        }));\n\n        function loadWorkletProcessorCode() {\n          return _loadWorkletProcessorCode.apply(this, arguments);\n        }\n\n        return loadWorkletProcessorCode;\n      }()\n    }, {\n      key: \"loadSample\",\n      value: function loadSample(objectName, url) {\n        if (this.audioContext !== undefined) {\n          (0, _maximilianUtil.loadSampleToArray)(this.audioContext, objectName, url, this.audioWorkletNode);\n        } else throw \"Audio Context is not initialised!\";\n      } // getSamplesNamegetSamplesNamess() {\n      // \tconst r = require.context(\"../../assets/samples\", false, /\\.wav$/);\n      // \t// return an array list of filenames (with extension)\n      // \tconst importAll = (r) => r.keys().map((file) => file.match(/[^\\/]+$/)[0]);\n      // \treturn importAll(r);\n      // }\n      // lazyLoadSample(sampleName) {\n      // \timport(/* webpackMode: 'lazy' */ `../../assets/samples/${sampleName}`)\n      // \t\t.then(() => this.loadSample(sampleName, `/samples/${sampleName}`))\n      // \t\t.catch((err) =>\n      // \t\t\tconsole.error(`DEBUG:AudioEngine:lazyLoadSample: ` + err)\n      // \t\t);\n      // }\n      // loadImportedSamples() {\n      // \tlet samplesNames = this.getSamplesNames();\n      // \t// console.log('DEBUG:AudioEngine:getSamplesNames: ' + samplesNames);\n      // \tsamplesNames.forEach((sampleName) => {\n      // \t\tthis.lazyLoadSample(sampleName);\n      // \t});\n      // }\n      // NOTE:FB Test code should be segregated from production code into its own fixture.\n      // Otherwise, it becomes bloated, difficult to read and reason about.\n      // messageHandler(data) {\n      // \tif (data == 'dspStart') {\n      // \t\tthis.ts = window.performance.now();\n      // \t}\n      // \tif (data == 'dspEnd') {\n      // \t\tthis.ts = window.performance.now() - this.ts;\n      // \t\tthis.dspTime = this.dspTime * 0.9 + this.ts * 0.1; //time for 128 sample buffer\n      // \t\tthis.onNewDSPLoadValue((this.dspTime / 2.90249433106576) * 100);\n      // \t}\n      // \tif (data == 'evalEnd') {\n      // \t\tlet evalts = window.performance.now();\n      // \t\tthis.onEvalTimestamp(evalts);\n      // \t} else if (data == 'evalEnd') {\n      // \t\tlet evalts = window.performance.now();\n      // \t\tthis.onEvalTimestamp(evalts);\n      // \t} else if (data == 'giveMeSomeSamples') {\n      // \t\t// this.msgHandler('giveMeSomeSamples');    \t// NOTE:FB Untangling the previous msgHandler hack from the audio engine\n      // \t} else {\n      // \t\tthis.msgHandler(data);\n      // \t}\n      // }\n\n    }]);\n    return AudioEngine;\n  }();\n\n  _exports.AudioEngine = AudioEngine;\n});\n\n//# sourceURL=webpack://sema-engine/./src/engine/audioEngine.js?");

/***/ }),

/***/ "./src/engine/maximilian.util.js":
/*!***************************************!*\
  !*** ./src/engine/maximilian.util.js ***!
  \***************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.translateBlobToBuffer = _exports.generateNoiseBuffer = _exports.runProcessorCode = _exports.buildWorkletFromBlob = _exports.createAndRegisterCustomProcessorCode = _exports.buildWorkletStringForBlob = _exports.loadSampleToArray = _exports.removePaddingFromBase64 = _exports._keyStr = _exports.getBase64 = _exports.getArrayAsVectorDbl = void 0;\n\n  var _this = void 0;\n\n  var getArrayAsVectorDbl = function getArrayAsVectorDbl(arrayIn) {\n    var vecOut = new exports.VectorDouble();\n\n    for (var i = 0; i < arrayIn.length; i++) {\n      vecOut.push_back(arrayIn[i]);\n    }\n\n    return vecOut;\n  };\n\n  _exports.getArrayAsVectorDbl = getArrayAsVectorDbl;\n\n  var getBase64 = function getBase64(str) {\n    //check if the string is a data URI\n    if (str.indexOf(';base64,') !== -1) {\n      //see where the actual data begins\n      var dataStart = str.indexOf(';base64,') + 8; //check if the data is base64-encoded, if yes, return it\n      // taken from\n      // http://stackoverflow.com/a/8571649\n\n      return str.slice(dataStart).match(/^([A-Za-z0-9+\\/]{4})*([A-Za-z0-9+\\/]{4}|[A-Za-z0-9+\\/]{3}=|[A-Za-z0-9+\\/]{2}==)$/) ? str.slice(dataStart) : false;\n    } else return false;\n  };\n\n  _exports.getBase64 = getBase64;\n  var _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  _exports._keyStr = _keyStr;\n\n  var removePaddingFromBase64 = function removePaddingFromBase64(input) {\n    var lkey = Module.maxiTools._keyStr.indexOf(input.charAt(input.length - 1));\n\n    if (lkey === 64) {\n      return input.substring(0, input.length - 1);\n    }\n\n    return input;\n  };\n\n  _exports.removePaddingFromBase64 = removePaddingFromBase64;\n\n  var loadSampleToArray = function loadSampleToArray(audioContext, sampleObjectName, url, audioWorkletNode) {\n    var data = [];\n    var context = audioContext; //check if url is actually a base64-encoded string\n\n    var b64 = getBase64(url);\n\n    if (b64) {\n      //convert to arraybuffer\n      //modified version of this:\n      // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js\n      var ab_bytes = b64.length / 4 * 3;\n      var arrayBuffer = new ArrayBuffer(ab_bytes);\n      b64 = removePaddingFromBase64(removePaddingFromBase64(b64));\n      var bytes = parseInt(b64.length / 4 * 3, 10);\n      var uarray;\n      var chr1, chr2, chr3;\n      var enc1, enc2, enc3, enc4;\n      var i = 0;\n      var j = 0;\n      uarray = new Uint8Array(arrayBuffer);\n      b64 = b64.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n      for (i = 0; i < bytes; i += 3) {\n        //get the 3 octects in 4 ascii chars\n        enc1 = _keyStr.indexOf(b64.charAt(j++));\n        enc2 = _keyStr.indexOf(b64.charAt(j++));\n        enc3 = _keyStr.indexOf(b64.charAt(j++));\n        enc4 = _keyStr.indexOf(b64.charAt(j++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        uarray[i] = chr1;\n\n        if (enc3 !== 64) {\n          uarray[i + 1] = chr2;\n        }\n\n        if (enc4 !== 64) {\n          uarray[i + 2] = chr3;\n        }\n      } // https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n      // Asynchronously decodes the audio file data contained in the ArrayBuffer.\n\n\n      audioContext.decodeAudioData(arrayBuffer, // has its content-type determined by sniffing\n      function (buffer) {\n        // successCallback, argument is an AudioBuffer representing the decoded PCM audio data.\n        // source.buffer = buffer;\n        // source.loop = true;\n        // source.start(0);\n        var float32ArrayBuffer = buffer.getChannelData(0);\n\n        if (data !== undefined && audioWorkletNode !== undefined) {\n          // console.log('f32array: ' + float32Array);\n          audioWorkletNode.port.postMessage({\n            \"sample\": sampleObjectName,\n            \"buffer\": float32ArrayBuffer\n          });\n        }\n      }, function (buffer) {\n        // errorCallback\n        console.log(\"Error decoding source!\");\n      });\n    } else {\n      // Load asynchronously\n      // NOTE: This is giving me an error\n      // Uncaught ReferenceError: XMLHttpRequest is not defined (index):97 MaxiProcessor Error detected: undefined\n      // NOTE: followed the trail to the wasmmodule.js\n      // when loading on if (typeof XMLHttpRequest !== 'undefined') {\n      // throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers.\n      // Use --embed-file or --preload-file in emcc on the main thread.\");\n      var request = new XMLHttpRequest();\n      request.addEventListener(\"load\", function () {\n        return console.log(\"The transfer is complete.\");\n      });\n      request.open(\"GET\", url, true);\n      request.responseType = \"arraybuffer\";\n\n      request.onload = function () {\n        audioContext.decodeAudioData(request.response, function (buffer) {\n          var float32ArrayBuffer = buffer.getChannelData(0);\n\n          if (data !== undefined && audioWorkletNode !== undefined) {\n            // console.log('f32array: ' + float32Array);\n            audioWorkletNode.port.postMessage({\n              \"sample\": sampleObjectName,\n              \"buffer\": float32ArrayBuffer\n            });\n          }\n        }, function (buffer) {\n          console.log(\"Error decoding source!\");\n        });\n      };\n\n      request.send();\n    }\n\n    return \"Loading module\";\n  };\n  /**\n   * @buildWorkletStringForBlob\n   */\n\n\n  _exports.loadSampleToArray = loadSampleToArray;\n\n  var buildWorkletStringForBlob = function buildWorkletStringForBlob() {\n    var userDefinedFunction = \"\";\n\n    switch (expression % 2) {\n      case 0:\n        userDefinedFunction = \"Math.random() * 2\";\n        break;\n\n      case 1:\n        userDefinedFunction = \"(Math.sin(400) + 0.4)\";\n        break;\n\n      default:\n        userDefinedFunction = \"(Math.sin(440) + 0.4)\";\n    } // We get an \"Error on loading worklet:  DOMException\" with the following import:\n    // import Module from './maximilian.wasmmodule.js';\n\n\n    return \"\\n      import Module from './maximilian.wasmmodule.js';\\n      cwlass CustomProcessor extends AudioWorkletProcessor {\\n        static get parameterDescriptors() {\\n          return [{\\n            name: 'gain',\\n            defaultValue: 0.1\\n          }];\\n        }\\n        constructor() {\\n          super();\\n          this.sampleRate = 44100;\\n\\n          this.port.onmessage = (event) => {\\n            console.log(event.data);\\n          };\\n\\n        }\\n        process(inputs, outputs, parameters) {\\n\\n          const outputsLength = outputs.length;\\n          for (let outputId = 0; outputId < outputsLength; ++outputId) {\\n            let output = outputs[outputId];\\n            const channelLenght = output.length;\\n\\n            for (let channelId = 0; channelId < channelLenght; ++channelId) {\\n              const gain = parameters.gain;\\n              const isConstant = gain.length === 1\\n              let outputChannel = output[channelId];\\n\\n              for (let i = 0; i < outputChannel.length; ++i) {\\n                const amp = isConstant ? gain[0] : gain[i]\\n                outputChannel[i] = \".concat(userDefinedFunction, \" * amp;\\n              }\\n            }\\n          }\\n          return true;\\n        }\\n      }\");\n  };\n  /**\n   * @createAndRegisterCustomProcessorCode\n   */\n\n\n  _exports.buildWorkletStringForBlob = buildWorkletStringForBlob;\n\n  var createAndRegisterCustomProcessorCode = function createAndRegisterCustomProcessorCode(il2pCode, processorName) {\n    return \"\".concat(il2pCode, \"\\n\\n    registerProcessor(\\\"\").concat(processorName, \"\\\", CustomProcessor);\");\n  };\n  /**\n   * @buildWorkletStringForBlob\n   */\n\n\n  _exports.createAndRegisterCustomProcessorCode = createAndRegisterCustomProcessorCode;\n\n  var buildWorkletFromBlob = function buildWorkletFromBlob() {\n    console.log('processorCount: ' + _this.processorCount); // const userCode = editor.getDoc().getValue();\n\n    var processorName = \"processor-\".concat(_this.processorCount);\n    _this.il2pCode = _this.translateIntermediateLanguageToProcessorCode(_this.processorCount);\n\n    var code = _this.createAndRegisterCustomProcessorCode(_this.il2pCode, processorName);\n\n    console.log(code);\n    var blob = new Blob([code], {\n      type: \"application/javascript; charset=utf-8\"\n    });\n    return blob;\n  };\n  /**\n   * TODO: Check for memory leaks\n   * @runProcessorCode\n   */\n\n\n  _exports.buildWorkletFromBlob = buildWorkletFromBlob;\n\n  var runProcessorCode = function runProcessorCode() {\n    // TODO: Check for memory leaks\n    // URL.revokeObjectURL()\n    var workletUrl = window.URL.createObjectURL(blob); // Set custom processor in audio worklet\n\n    _this.audioContext.audioWorklet.addModule(workletUrl).then(function () {\n      _this.stop();\n\n      _this.customNode = new CustomAudioNode(_this.audioContext, processorName);\n\n      _this.customNode.port.onmessage = function (event) {\n        //  data from the processor.\n        console.log(\"from processor: \" + event.data);\n      };\n\n      _this.customNode.connect(_this.audioContext.destination);\n    })[\"catch\"](function (e) {\n      return console.log(\"Error on loading worklet: \", e);\n    });\n  };\n\n  _exports.runProcessorCode = runProcessorCode;\n\n  var generateNoiseBuffer = function generateNoiseBuffer(length) {\n    var bufferData = new Module.VectorDouble();\n\n    for (var n = 0; n < length; n++) {\n      bufferData.push_back(Math.random(1));\n    }\n\n    return bufferData;\n  };\n\n  _exports.generateNoiseBuffer = generateNoiseBuffer;\n\n  var translateBlobToBuffer = function translateBlobToBuffer(blob) {\n    var arrayBuffer = null;\n    var float32Array = null;\n    var fileReader = new FileReader();\n\n    fileReader.onload = function (event) {\n      arrayBuffer = event.target.result;\n      float32Array = new Float32Array(arrayBuffer);\n    };\n\n    fileReader.readAsArrayBuffer(blob);\n    var audioFloat32Array = fileReader.result;\n    var maxiSampleBufferData = new Module.VectorDouble();\n\n    for (var i = 0; i < audioFloat32Array.length; i++) {\n      maxiSampleBufferData.push_back(audioFloat32Array[i]);\n    }\n\n    return maxiSampleBufferData;\n  };\n\n  _exports.translateBlobToBuffer = translateBlobToBuffer;\n});\n\n//# sourceURL=webpack://sema-engine/./src/engine/maximilian.util.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./engine/audioEngine.js */ \"./src/engine/audioEngine.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _audioEngine) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  Object.defineProperty(_exports, \"AudioEngine\", {\n    enumerable: true,\n    get: function get() {\n      return _audioEngine.AudioEngine;\n    }\n  });\n});\n\n//# sourceURL=webpack://sema-engine/./src/index.js?");

/***/ }),

/***/ "./src/engine/ringbuf.js":
/*!*******************************!*\
  !*** ./src/engine/ringbuf.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"ringbuf.js\");\n\n//# sourceURL=webpack://sema-engine/./src/engine/ringbuf.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n//# sourceURL=webpack://sema-engine/./node_modules/regenerator-runtime/runtime.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.js");
/******/ })()
;
});