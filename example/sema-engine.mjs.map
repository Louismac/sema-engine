{"version":3,"file":"sema-engine.mjs","sources":["../src/engine/ringbuf.js","../src/engine/maximilian.util.js","../src/engine/audioEngine.js"],"sourcesContent":["//warning this is the same as in ringbuf, but packaged differently - needs fixing!!!\nexport default class RingBuffer {\n  static getStorageForCapacity(capacity, type) {\n    if (!type.BYTES_PER_ELEMENT) {\n      throw 'Pass in a ArrayBuffer subclass';\n    }\n    var bytes = 8 + (capacity + 1) * type.BYTES_PER_ELEMENT;\n    return new SharedArrayBuffer(bytes);\n  }\n  // `sab` is a SharedArrayBuffer with a capacity calculated by calling\n  // `getStorageForCapacity` with the desired capacity.\n  constructor(sab, type) {\n    if (!ArrayBuffer.__proto__.isPrototypeOf(type) &&\n      type.BYTES_PER_ELEMENT !== undefined) {\n      throw 'Pass a concrete typed array class as second argument';\n    }\n\n    // Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring\n    // buffer for this version, easily changeable.\n    // -4 for the write ptr (uint32_t offsets)\n    // -4 for the read ptr (uint32_t offsets)\n    // capacity counts the empty slot to distinguish between full and empty.\n    this._type = type;\n    this.capacity = (sab.byteLength - 8) / type.BYTES_PER_ELEMENT;\n    this.buf = sab;\n    this.write_ptr = new Uint32Array(this.buf, 0, 1);\n    this.read_ptr = new Uint32Array(this.buf, 4, 1);\n    this.storage = new type(this.buf, 8, this.capacity);\n  }\n  // Returns the type of the underlying ArrayBuffer for this RingBuffer. This\n  // allows implementing crude type checking.\n  type() {\n    return this._type.name;\n  }\n  // Push bytes to the ring buffer. `bytes` is an typed array of the same type\n  // as passed in the ctor, to be written to the queue.\n  // Returns the number of elements written to the queue.\n  push(elements) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if ((wr + 1) % this._storage_capacity() == rd) {\n      // full\n      return 0;\n    }\n\n    let to_write = Math.min(this._available_write(rd, wr), elements.length);\n    let first_part = Math.min(this._storage_capacity() - wr, to_write);\n    let second_part = to_write - first_part;\n\n    this._copy(elements, 0, this.storage, wr, first_part);\n    this._copy(elements, first_part, this.storage, 0, second_part);\n\n    // publish the enqueued data to the other side\n    Atomics.store(\n      this.write_ptr,\n      0,\n      (wr + to_write) % this._storage_capacity()\n    );\n\n    return to_write;\n  }\n  // Read `elements.length` elements from the ring buffer. `elements` is a typed\n  // array of the same type as passed in the ctor.\n  // Returns the number of elements read from the queue, they are placed at the\n  // beginning of the array passed as parameter.\n  pop(elements) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if (wr == rd) {\n      return 0;\n    }\n\n    let to_read = Math.min(this._available_read(rd, wr), elements.length);\n\n    let first_part = Math.min(this._storage_capacity() - rd, elements.length);\n    let second_part = to_read - first_part;\n\n    this._copy(this.storage, rd, elements, 0, first_part);\n    this._copy(this.storage, 0, elements, first_part, second_part);\n\n    Atomics.store(this.read_ptr, 0, (rd + to_read) % this._storage_capacity());\n\n    return to_read;\n  }\n\n  // True if the ring buffer is empty false otherwise. This can be late on the\n  // reader side: it can return true even if something has just been pushed.\n  empty() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return wr == rd;\n  }\n\n  // True if the ring buffer is full, false otherwise. This can be late on the\n  // write side: it can return true when something has just been poped.\n  full() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return (wr + 1) % this.capacity != rd;\n  }\n\n  // The usable capacity for the ring buffer: the number of elements that can be\n  // stored.\n  capacity() {\n    return this.capacity - 1;\n  }\n\n  // Number of elements available for reading. This can be late, and report less\n  // elements that is actually in the queue, when something has just been\n  // enqueued.\n  available_read() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_read(rd, wr);\n  }\n\n  // Number of elements available for writing. This can be late, and report less\n  // elements that is actually available for writing, when something has just\n  // been dequeued.\n  available_write() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_write(rd, wr);\n  }\n\n  // private methods //\n\n  // Number of elements available for reading, given a read and write pointer..\n  _available_read(rd, wr) {\n    if (wr > rd) {\n      return wr - rd;\n    } else {\n      return wr + this._storage_capacity() - rd;\n    }\n  }\n\n  // Number of elements available from writing, given a read and write pointer.\n  _available_write(rd, wr) {\n    let rv = rd - wr - 1;\n    if (wr >= rd) {\n      rv += this._storage_capacity();\n    }\n    return rv;\n  }\n\n  // The size of the storage for elements not accounting the space for the index.\n  _storage_capacity() {\n    return this.capacity;\n  }\n\n  // Copy `size` elements from `input`, starting at offset `offset_input`, to\n  // `output`, starting at offset `offset_output`.\n  _copy(input, offset_input, output, offset_output, size) {\n    for (var i = 0; i < size; i++) {\n      output[offset_output + i] = input[offset_input + i];\n    }\n  }\n}\n\n","export const getArrayAsVectorDbl = (arrayIn) => {\n  var vecOut = new exports.VectorDouble();\n  for (var i = 0; i < arrayIn.length; i++) {\n    vecOut.push_back(arrayIn[i]);\n  }\n  return vecOut;\n};\n\nexport const getBase64 = (str) => {\n  //check if the string is a data URI\n  if (str.indexOf(';base64,') !== -1) {\n    //see where the actual data begins\n    var dataStart = str.indexOf(';base64,') + 8;\n    //check if the data is base64-encoded, if yes, return it\n    // taken from\n    // http://stackoverflow.com/a/8571649\n    return str.slice(dataStart).match(/^([A-Za-z0-9+\\/]{4})*([A-Za-z0-9+\\/]{4}|[A-Za-z0-9+\\/]{3}=|[A-Za-z0-9+\\/]{2}==)$/) ? str.slice(dataStart) : false;\n  } else return false;\n};\n\nexport const _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nexport const removePaddingFromBase64 = (input) => {\n  var lkey = Module.maxiTools._keyStr.indexOf(input.charAt(input.length - 1));\n  if (lkey === 64) {\n    return input.substring(0, input.length - 1);\n  }\n  return input;\n};\n\n\nexport const loadSampleToArray = (audioContext, sampleObjectName, url, audioWorkletNode) => {\n  var data = [];\n\n  var context = audioContext;\n\n  //check if url is actually a base64-encoded string\n  var b64 = getBase64(url);\n  if (b64) {\n    //convert to arraybuffer\n    //modified version of this:\n    // https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js\n    var ab_bytes = (b64.length / 4) * 3;\n    var arrayBuffer = new ArrayBuffer(ab_bytes);\n\n    b64 = removePaddingFromBase64(removePaddingFromBase64(b64));\n\n    var bytes = parseInt((b64.length / 4) * 3, 10);\n\n    var uarray;\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0;\n    var j = 0;\n\n    uarray = new Uint8Array(arrayBuffer);\n\n    b64 = b64.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    for (i = 0; i < bytes; i += 3) {\n      //get the 3 octects in 4 ascii chars\n      enc1 = _keyStr.indexOf(b64.charAt(j++));\n      enc2 = _keyStr.indexOf(b64.charAt(j++));\n      enc3 = _keyStr.indexOf(b64.charAt(j++));\n      enc4 = _keyStr.indexOf(b64.charAt(j++));\n\n      chr1 = (enc1 << 2) | (enc2 >> 4);\n      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n      chr3 = ((enc3 & 3) << 6) | enc4;\n\n      uarray[i] = chr1;\n      if (enc3 !== 64) {\n        uarray[i + 1] = chr2;\n      }\n      if (enc4 !== 64) {\n        uarray[i + 2] = chr3;\n      }\n    }\n\n    // https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n    // Asynchronously decodes the audio file data contained in the ArrayBuffer.\n    audioContext.decodeAudioData(\n      arrayBuffer, // has its content-type determined by sniffing\n      function (buffer) { // successCallback, argument is an AudioBuffer representing the decoded PCM audio data.\n        // source.buffer = buffer;\n        // source.loop = true;\n        // source.start(0);\n        let float32ArrayBuffer = buffer.getChannelData(0);\n        if (data !== undefined && audioWorkletNode !== undefined) {\n          // console.log('f32array: ' + float32Array);\n          audioWorkletNode.port.postMessage({\n            \"sample\":sampleObjectName,\n            \"buffer\": float32ArrayBuffer,\n          });\n        }\n      },\n      function (buffer) { // errorCallback\n        console.log(\"Error decoding source!\");\n      }\n    );\n  } else {\n    // Load asynchronously\n    // NOTE: This is giving me an error\n    // Uncaught ReferenceError: XMLHttpRequest is not defined (index):97 MaxiProcessor Error detected: undefined\n    // NOTE: followed the trail to the wasmmodule.js\n    // when loading on if (typeof XMLHttpRequest !== 'undefined') {\n    // throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers.\n    // Use --embed-file or --preload-file in emcc on the main thread.\");\n    var request = new XMLHttpRequest();\n    request.addEventListener(\"load\", () => console.log(\"The transfer is complete.\"));\n    request.open(\"GET\", url, true);\n    request.responseType = \"arraybuffer\";\n    request.onload = function () {\n      audioContext.decodeAudioData(\n        request.response,\n        function (buffer) {\n          let float32ArrayBuffer = buffer.getChannelData(0);\n          if (data !== undefined && audioWorkletNode !== undefined) {\n            // console.log('f32array: ' + float32Array);\n            audioWorkletNode.port.postMessage({\n              \"sample\":sampleObjectName,\n              \"buffer\": float32ArrayBuffer,\n            });\n          }\n        },\n        function (buffer) {\n          console.log(\"Error decoding source!\");\n        }\n      );\n    };\n    request.send();\n  }\n  return \"Loading module\";\n};\n\n/**\n * @buildWorkletStringForBlob\n */\nexport const buildWorkletStringForBlob = (userDefinedFunction) => {\n\t// let = \"\";\n\t// switch (expression % 2) {\n\t// \tcase 0:\n\t// \t\tuserDefinedFunction = `Math.random() * 2`;\n\t// \t\tbreak;\n\t// \tcase 1:\n\t// \t\tuserDefinedFunction = `(Math.sin(400) + 0.4)`;\n\t// \t\tbreak;\n\t// \tdefault:\n\t// \t\tuserDefinedFunction = `(Math.sin(440) + 0.4)`;\n\t// }\n\n\t// We get an \"Error on loading worklet:  DOMException\" with the following import:\n\t// import Module from './maximilian.wasmmodule.js';\n\treturn `\n      import Module from './maximilian.wasmmodule.js';\n      cwlass CustomProcessor extends AudioWorkletProcessor {\n        static get parameterDescriptors() {\n          return [{\n            name: 'gain',\n            defaultValue: 0.1\n          }];\n        }\n        constructor() {\n          super();\n          this.sampleRate = 44100;\n\n          this.port.onmessage = (event) => {\n            console.log(event.data);\n          };\n\n        }\n        process(inputs, outputs, parameters) {\n\n          const outputsLength = outputs.length;\n          for (let outputId = 0; outputId < outputsLength; ++outputId) {\n            let output = outputs[outputId];\n            const channelLenght = output.length;\n\n            for (let channelId = 0; channelId < channelLenght; ++channelId) {\n              const gain = parameters.gain;\n              const isConstant = gain.length === 1\n              let outputChannel = output[channelId];\n\n              for (let i = 0; i < outputChannel.length; ++i) {\n                const amp = isConstant ? gain[0] : gain[i]\n                outputChannel[i] = ${userDefinedFunction} * amp;\n              }\n            }\n          }\n          return true;\n        }\n      }`;\n};\n\n/**\n * @createAndRegisterCustomProcessorCode\n */\nexport const createAndRegisterCustomProcessorCode = (il2pCode, processorName) => {\n\n  return `${il2pCode}\n\n    registerProcessor(\"${processorName}\", CustomProcessor);`;\n}\n\n/**\n * @buildWorkletStringForBlob\n */\nexport const buildWorkletFromBlob = () => {\n  // console.log('processorCount: ' + this.processorCount);\n  // // const userCode = editor.getDoc().getValue();\n  // const processorName = `processor-${this.processorCount}`;\n\n  // this.il2pCode = this.translateIntermediateLanguageToProcessorCode(this.processorCount);\n\n  // const code = this.createAndRegisterCustomProcessorCode(this.il2pCode, processorName);\n\n  // console.log(code);\n\n  // const blob = new Blob([code], {\n  //   type: \"application/javascript; charset=utf-8\",\n  // });\n\n  return blob;\n}\n\n/**\n * TODO: Check for memory leaks\n * @runProcessorCode\n */\n// export const runProcessorCode = () => {\n//   // TODO: Check for memory leaks\n//   // URL.revokeObjectURL()\n//   const workletUrl = window.URL.createObjectURL(blob);\n\n//   // Set custom processor in audio worklet\n//   this.audioContext.audioWorklet.addModule(workletUrl).then(() => {\n//     this.stop();\n//     this.customNode = new CustomAudioNode(this.audioContext, processorName);\n//     this.customNode.port.onmessage = (event) => {\n//       //  data from the processor.\n//       console.log(\"from processor: \" + event.data);\n//     };\n//     this.customNode.connect(this.audioContext.destination);\n//   }).catch(e => console.log(\"Error on loading worklet: \", e));\n// }\n\n\nexport const generateNoiseBuffer = (length) => {\n  var bufferData = new Module.VectorDouble();\n  for (var n = 0; n < length; n++) {\n    bufferData.push_back(Math.random(1));\n  }\n  return bufferData;\n}\n\n\nexport const translateBlobToBuffer = (blob) => {\n\n  let arrayBuffer = null;\n  let float32Array = null;\n  var fileReader = new FileReader();\n  fileReader.onload = function (event) {\n    arrayBuffer = event.target.result;\n    float32Array = new Float32Array(arrayBuffer);\n  };\n  fileReader.readAsArrayBuffer(blob);\n  let audioFloat32Array = fileReader.result;\n  var maxiSampleBufferData = new Module.VectorDouble();\n  for (var i = 0; i < audioFloat32Array.length; i++) {\n    maxiSampleBufferData.push_back(audioFloat32Array[i]);\n  }\n  return maxiSampleBufferData;\n}\n","import RingBuffer from './ringbuf.js'; //thanks padenot\nimport {\n  loadSampleToArray\n} from './maximilian.util.js';\n// import {\n//   kuramotoNetClock\n// } from './interfaces/clockInterface.js';\n// import {\n//   PubSub\n// } from './messaging/pubSub.js';\n// import {\n//   PeerStreaming\n// } from '../interfaces/peerStreaming.js';\n// import {\n//   copyToPasteBuffer\n// } from '../utils/pasteBuffer.js';\n\n\n/**\n * The CustomMaxiNode is a class that extends AudioWorkletNode\n * to hold an Custom Audio Worklet Processor and connect to Web Audio graph\n * @class CustomMaxiNode\n * @extends AudioWorkletNode\n */\n// if(true){\nclass CustomMaxiNode extends AudioWorkletNode {\n  constructor(audioContext, processorName) {\n    // super(audioContext, processorName);\n    console.log();\n    let options = {\n      numberOfInputs: 1,\n      numberOfOutputs: 1,\n      outputChannelCount: [audioContext.destination.maxChannelCount]\n    };\n    super(audioContext, processorName, options);\n  }\n}\n// }\n\n/**\n * The AudioEngine is a singleton class that encapsulates the AudioContext\n * and all WASM and Maximilian -powered Audio Worklet Processor\n * @class AudioEngine\n */\nclass AudioEngine {\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tif (AudioEngine.instance) {\n\t\t\treturn AudioEngine.instance; // Singleton pattern\n\t\t}\n\t\tAudioEngine.instance = this;\n\n\t\t// Hash of on-demand analysers (e.g. spectrogram, oscilloscope)\n\t\t// NOTE: analysers serialized to localStorage are de-serialized and loaded from local Storage before user-started audioContext init\n\t\tthis.analysers = {};\n\n\t\t// Shared array buffers for sharing client side data to the audio engine- e.g. mouse coords\n\t\tthis.sharedArrayBuffers = {};\n\n\t\t// MOVE THIS TO AN UP LAYER IN SEMA\n\n\t\t// Sema's Publish-Subscribe pattern object with 'lowercase-lowercase' format convention for subscription topic\n\t\t// this.messaging = new PubSub();\n\t\t// this.messaging.subscribe('eval-dsp', e => this.evalDSP(e));\n\t\t// this.messaging.subscribe('stop-audio', e => this.stop());\n\t\t// this.messaging.subscribe('load-sample', (name, url) =>\n\t\t//   this.loadSample(name, url)\n\t\t// );\n\t\t// this.messaging.subscribe('model-output-data', e =>\n\t\t//   this.onMessagingEventHandler(e)\n\t\t// );\n\t\t// this.messaging.subscribe('clock-phase', e =>\n\t\t//   this.onMessagingEventHandler(e)\n\t\t// );\n\t\t// this.messaging.subscribe('model-send-buffer', e =>\n\t\t//   this.onMessagingEventHandler(e)\n\t\t// );\n\t\t// this.messaging.subscribe('add-engine-analyser', e =>\n\t\t//   this.createAnalyser(e)\n\t\t// );\n\t\t// this.messaging.subscribe('remove-engine-analyser', e =>\n\t\t//   this.removeAnalyser(e)\n\t\t// );\n\n\t\t// this.messaging.subscribe('mouse-xy', e => {\n\t\t//   if (this.sharedArrayBuffers.mxy) {\n\t\t//     this.sharedArrayBuffers.mxy.rb.push(e);\n\t\t//   }\n\t\t// });\n\t\t// this.messaging.subscribe('osc', e => console.log(`DEBUG:AudioEngine:OSC: ${e}`));\n\n\t\t//temporarily disabled for now\n\t\t// this.kuraClock = new kuramotoNetClock();\n\n\t\t//temporarily disabled for now\n\t\t// this.peerNet = new PeerStreaming();\n\n\t\t//the message has incoming data from other peers\n\t\t// this.messaging.subscribe('peermsg', (e) => {\n\t\t//   e.ttype = 'NET';\n\t\t//   e.peermsg = 1;\n\t\t//   this.onMessagingEventHandler(e);\n\t\t// });\n\n\t\t// this.messaging.subscribe('peerinfo-request', (e) => {\n\t\t//   console.log(this.peerNet.peerID);\n\t\t//   copyToPasteBuffer(this.peerNet.peerID);\n\t\t// });\n\t}\n\n\t/**\n\t * Handler of audio worklet processor events\n\t * @onProcessorMessageEventHandler\n\t */\n\tonProcessorMessageEventHandler(event) {\n\t\tif (event != undefined && event.data != undefined) {\n\t\t\t// console.log('DEBUG:AudioEngine:processorMessageHandler:');\n\t\t\t// console.log(event);\n\t\t\tif (event.data.rq != undefined && event.data.rq === \"send\") {\n\t\t\t\tswitch (event.data.ttype) {\n\t\t\t\t\tcase \"ML\":\n\t\t\t\t\t\t// Stream generated by 'toJS' live code instruction — e.g. {10,0,{1}sin}toJS;\n\t\t\t\t\t\t// publishes to model/JS editor, which posts to ml.worker\n\t\t\t\t\t\tthis.messaging.publish(\"model-input-data\", {\n\t\t\t\t\t\t\ttype: \"model-input-data\",\n\t\t\t\t\t\t\tvalue: event.data.value,\n\t\t\t\t\t\t\tch: event.data.ch,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"NET\":\n\t\t\t\t\t\tthis.peerNet.send(\n\t\t\t\t\t\t\tevent.data.ch[0],\n\t\t\t\t\t\t\tevent.data.value,\n\t\t\t\t\t\t\tevent.data.ch[1]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (event.data.rq && event.data.rq === \"buf\") {\n\t\t\t\tconsole.log(\"buf\", event.data);\n\t\t\t\tswitch (event.data.ttype) {\n\t\t\t\t\tcase \"ML\":\n\t\t\t\t\t\tthis.messaging.publish(\"model-input-buffer\", {\n\t\t\t\t\t\t\ttype: \"model-input-buffer\",\n\t\t\t\t\t\t\tvalue: event.data.value,\n\t\t\t\t\t\t\tchannelID: event.data.channelID, //channel ID\n\t\t\t\t\t\t\tblocksize: event.data.blocksize,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (event.data === \"giveMeSomeSamples\") {\n\t\t\t} else if (event.data.phase != undefined) {\n\t\t\t\t// console.log('DEBUG:AudioEngine:phase:');\n\t\t\t\t// console.log(event.data.phase);\n\t\t\t\t// this.kuraClock.broadcastPhase(event.data.phase); // TODO Refactor p to phase\n\t\t\t}\n\t\t\t// else if (event.data.rq != undefined && event.data.rq === 'receive') {\n\t\t\t//   switch (event.data.ttype) {\n\t\t\t//     case 'ML':\n\t\t\t//       // Stream generated by 'fromJS' live code instruction – e.g. {{10,1}fromJS}saw\n\t\t\t//       // publishes to model/JS editor, which posts to ml.worker\n\t\t\t//       this.messaging.publish('model-output-data-request', {\n\t\t\t//         type: 'model-output-data-request',\n\t\t\t//         value: event.data.value,\n\t\t\t//         channel: event.data.ch\n\t\t\t//       });\n\t\t\t//       break;\n\t\t\t//     case 'NET':\n\t\t\t//       break;\n\t\t\t//   }\n\t\t\t// }\n\t\t}\n\t}\n\n\t/**\n\t * Handler of the Pub/Sub message events\n\t * whose topics are subscribed to in the audio engine constructor\n\t * @onMessagingEventHandler\n\t */\n\tpostAsyncMessageToProcessor(event) {\n\t\tif (event !== undefined) {\n\t\t\t// Receive notification from 'model-output-data' topic\n\t\t\tconsole.log(\"DEBUG:AudioEngine:onMessagingEventHandler:\");\n\t\t\tconsole.log(event);\n\t\t\tthis.audioWorkletNode.port.postMessage(event);\n\t\t}\n\t}\n\n\t/**\n\t * Polls data from connected WAAPI analyser return structured object with data and time data in arrays\n\t * @param {*} analyser\n\t */\n\tpollAnalyserData(analyser) {\n\t\tif (analyser !== undefined) {\n\t\t\tconst timeDataArray = new Uint8Array(analyser.fftSize); // Uint8Array should be the same length as the fftSize\n\t\t\tconst frequencyDataArray = new Uint8Array(analyser.fftSize);\n\n\t\t\tanalyser.getByteTimeDomainData(timeDataArray);\n\t\t\tanalyser.getByteFrequencyData(frequencyDataArray);\n\n\t\t\treturn {\n\t\t\t\tsmoothingTimeConstant: analyser.smoothingTimeConstant,\n\t\t\t\tfftSize: analyser.fftSize,\n\t\t\t\tfrequencyDataArray: frequencyDataArray,\n\t\t\t\ttimeDataArray: timeDataArray,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a WAAPI analyser node\n\t * @todo configuration object as argumen\n\t * @createAnalyser\n\t */\n\tcreateAnalyser(analyserID, callback) {\n\t\t// If Analyser creation happens after AudioContext intialization, create and connect WAAPI analyser\n\t\tif (this.audioContext !== undefined && event !== undefined) {\n\n\t\t\tlet analyser = this.audioContext.createAnalyser();\n\t\t\tanalyser.smoothingTimeConstant = 0.25;\n\t\t\tanalyser.fftSize = 256; // default 2048;\n\t\t\tanalyser.minDecibels = -90; // default\n\t\t\tanalyser.maxDecibels = -0; // default -10; max 0\n\t\t\tthis.audioWorkletNode.connect(analyser);\n\n\n\t\t\tlet analyserFrameId = -1,\n          analyserData = {};\n\n\t\t\tthis.analysers[analyserID] = {\n\t\t\t\tanalyser,\n\t\t\t\tanalyserFrameId,\n\t\t\t\tcallback\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Creates requestAnimationFrame loop for polling data and publishing\n\t\t\t * Returns Analyser Frame ID for adding to Analysers hash and cancelling animation frame\n\t\t\t */\n\t\t\tconst analyserPollingLoop = () => {\n\n        analyserData = this.pollAnalyserData(this.analysers[analyserID].analyser);\n\n        this.analysers[analyserID].callback(analyserData); // Invoke callback that carries\n\n        // This will guarantee feeding poll request at steady animation framerate\n\t\t\t\tthis.analysers[analyserID].analyserFrameId = requestAnimationFrame(analyserPollingLoop);\n\n\t\t\t\treturn analyserFrameId;\n\t\t\t};\n\n\t\t\tanalyserPollingLoop();\n\n\t\t\t// Other if AudioContext is NOT created yet (after app load, before splashScreen click)\n\t\t} else if (this.audioContext === undefined) {\n\t\t\tthis.analysers[analyser] = {};\n\t\t}\n\t}\n\n\t/**\n\t * Connects WAAPI analyser nodes to the main audio worklet for visualisation.\n\t * @connectAnalysers\n\t */\n\tconnectAnalysers() {\n\t\tObject.keys(this.analysers).map((id) =>\n\t\t\tthis.createAnalyser({\n\t\t\t\tid,\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Removes a WAAPI analyser node, disconnects graph, cancels animation frame, deletes from hash\n\t * @removeAnalyser\n\t */\n\tremoveAnalyser(event) {\n\t\tif (\n\t\t\tthis.audioContext !== undefined &&\n\t\t\tthis.audioWorkletNode !== undefined\n\t\t) {\n\t\t\tlet analyser = this.analysers[event.id];\n\t\t\tif (analyser !== undefined) {\n\t\t\t\tcancelAnimationFrame(this.analysers[event.id].analyserFrameId);\n\t\t\t\tdelete this.analysers[event.id];\n\t\t\t\t// this.audioWorkletNode.disconnect(analyser);\n\t\t\t}\n\t\t}\n\t}\n\n\t//make a shared array buffer for communicating with the audio engine\n\tcreateSharedArrayBuffer(chID, ttype, blocksize) {\n\t\tlet sab = RingBuffer.getStorageForCapacity(32 * blocksize, Float64Array);\n\t\tlet ringbuf = new RingBuffer(sab, Float64Array);\n\n\t\tthis.audioWorkletNode.port.postMessage({\n\t\t\tfunc: \"sab\",\n\t\t\tvalue: sab,\n\t\t\tttype: ttype,\n\t\t\tchannelID: chID,\n\t\t\tblocksize: blocksize,\n\t\t});\n\n\t\tthis.sharedArrayBuffers[chID] = {\n\t\t\tsab: sab,\n\t\t\trb: ringbuf,\n\t\t};\n\n\t\tconsole.log(this.sharedArrayBuffers);\n\t}\n\n\t/**\n\t * Initialises audio context and sets worklet processor code\n\t * @play\n\t */\n\tasync init(audioWorkletURL /*numClockPeers*/) {\n\t\t// AudioContext needs lazy loading to workaround the Chrome warning\n\t\t// Audio Engine first play() call, triggered by user, prevents the warning\n\t\t// by setting this.audioContext = new AudioContext();\n\t\tthis.audioContext;\n\t\tthis.audioWorkletProcessorName = \"maxi-processor\";\n\t\tthis.audioWorkletUrl = audioWorkletURL;\n\t\tthis.samplesLoaded = false;\n\n\t\tif (this.audioContext === undefined) {\n\t\t\tthis.audioContext = new AudioContext({\n\t\t\t\t// create audio context with latency optimally configured for playback\n\t\t\t\tlatencyHint: \"playback\",\n\t\t\t\t// latencyHint: 32/44100,  //this doesn't work below 512 on chrome (?)\n\t\t\t\t// sampleRate: 44100\n\t\t\t});\n\n\t\t\tthis.audioContext.destination.channelInterpretation = \"discrete\";\n\t\t\tthis.audioContext.destination.channelCountMode = \"explicit\";\n\t\t\tthis.audioContext.destination.channelCount = this.audioContext.destination.maxChannelCount;\n\t\t\t// console.log(this.audioContext.destination);\n\n\t\t\tawait this.loadWorkletProcessorCode();\n\n\t\t\t// Connect the worklet node to the audio graph\n\t\t\tthis.audioWorkletNode.connect(this.audioContext.destination);\n\n\t\t\t// this.audioWorkletNode.channelInterpretation = 'discrete';\n\t\t\t// this.audioWorkletNode.channelCountMode = 'explicit';\n\t\t\t// this.audioWorkletNode.channelCount = this.audioContext.destination.maxChannelCount;\n\n\t\t\t// this.connectMediaStream();\n\n\t\t\t// this.connectAnalysers(); // Connect Analysers loaded from the store\n\n\t\t\t// this.loadImportedSamples();\n\n\t\t\t// No need to inject the callback here, messaging is built in KuraClock\n\t\t\t// this.kuraClock = new kuramotoNetClock((phase, idx) => {\n\t\t\t//   // console.log( `DEBUG:AudioEngine:sendPeersMyClockPhase:phase:${phase}:id:${idx}`);\n\t\t\t//   // This requires an initialised audio worklet\n\t\t\t//   this.audioWorkletNode.port.postMessage({ phase: phase, i: idx });\n\t\t\t// });\n\n\t\t\t//temporarily disabled\n\t\t\t// if (this.kuraClock.connected()) {\n\t\t\t// \tthis.kuraClock.queryPeers(async numClockPeers => {\n\t\t\t// \t\tconsole.log(`DEBUG:AudioEngine:init:numClockPeers: ${numClockPeers}`);\n\t\t\t// \t});\n\t\t\t// }\n\n\t\t\tthis.createSharedArrayBuffer(\"mxy\", \"mouseXY\", 2);\n\t\t}\n\t}\n\n\t/**\n\t * Initialises audio context and sets worklet processor code\n\t * or re-starts audio playback by stopping and running the latest Audio Worklet Processor code\n\t * @play\n\t */\n\tplay() {\n\t\tif (this.audioContext !== undefined) {\n\t\t\tif (this.audioContext.state !== \"suspended\") {\n\t\t\t\tthis.stop();\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthis.audioContext.resume();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Suspends AudioContext (Pause)\n\t * @stop\n\t */\n\tstop() {\n\t\tif (this.audioWorkletNode !== undefined) {\n\t\t\tthis.audioContext.suspend();\n\t\t}\n\t}\n\n\t/**\n\t * Stops audio by disconnecting AudioNode with AudioWorkletProcessor code\n\t * from Web Audio graph TODO Investigate when it is best to just STOP the graph exectution\n\t * @stop\n\t */\n\tstopAndRelease() {\n\t\tif (this.audioWorkletNode !== undefined) {\n\t\t\tthis.audioWorkletNode.disconnect(this.audioContext.destination);\n\t\t\tthis.audioWorkletNode = undefined;\n\t\t}\n\t}\n\n\tmore(gain) {\n\t\tif (this.audioWorkletNode !== undefined) {\n\t\t\tconst gainParam = this.audioWorkletNode.parameters.get(gain);\n\t\t\tgainParam.value += 0.5;\n\t\t\tconsole.log(gain + \": \" + gainParam.value); // DEBUG\n\t\t\treturn true;\n\t\t} else return false;\n\t}\n\n\tless(gain) {\n\t\tif (this.audioWorkletNode !== undefined) {\n\t\t\tconst gainParam = this.audioWorkletNode.parameters.get(gain);\n\t\t\tgainParam.value -= 0.5;\n\t\t\tconsole.log(gain + \": \" + gainParam.value); // DEBUG\n\t\t\treturn true;\n\t\t} else return false;\n\t}\n\n\teval(dspFunction) {\n\t\t// console.log('DEBUG:AudioEngine:evalDSP:');\n\t\t// console.log(dspFunction);\n\n\t\tif (this.audioWorkletNode !== undefined) {\n\t\t\tif (this.audioContext.state === \"suspended\") {\n\t\t\t\tthis.audioContext.resume();\n\t\t\t}\n\t\t\tthis.audioWorkletNode.port.postMessage({\n\t\t\t\teval: 1,\n\t\t\t\tsetup: dspFunction.setup,\n\t\t\t\tloop: dspFunction.loop,\n\t\t\t});\n\t\t\treturn true;\n\t\t} else return false;\n\t}\n\n\tsendClockPhase(phase, idx) {\n\t\tif (this.audioWorkletNode !== undefined) {\n\t\t\tthis.audioWorkletNode.port.postMessage({\n\t\t\t\tphase: phase,\n\t\t\t\ti: idx,\n\t\t\t});\n\t\t}\n\t}\n\n\tonAudioInputInit(stream) {\n\t\t// console.log('DEBUG:AudioEngine: Audio Input init');\n\t\tlet mediaStreamSource = this.audioContext.createMediaStreamSource(stream);\n\t\tmediaStreamSource.connect(this.audioWorkletNode);\n\t}\n\n\tonAudioInputFail(error) {\n\t\tconsole.log(\n\t\t\t`DEBUG:AudioEngine:AudioInputFail: ${error.message} ${error.name}`\n\t\t);\n\t}\n\n\t/**\n\t * Sets up an AudioIn WAAPI sub-graph\n\t * @connectMediaStreamSourceInput\n\t */\n\tasync connectMediaStream() {\n\t\tconst constraints = (window.constraints = {\n\t\t\taudio: true,\n\t\t\tvideo: false,\n\t\t});\n\n\t\tnavigator.mediaDevices\n\t\t\t.getUserMedia(constraints)\n\t\t\t.then((s) => this.onAudioInputInit(s))\n\t\t\t.catch(this.onAudioInputFail);\n\t}\n\n\t/**\n\t * Loads audioWorklet processor code into a worklet,\n\t * setups up all handlers (errors, async messaging, etc),\n\t * connects the worklet processor to the WAAPI graph\n\t */\n\tasync loadWorkletProcessorCode() {\n\t\tif (this.audioContext !== undefined) {\n\t\t\ttry {\n\t\t\t\tawait this.audioContext.audioWorklet.addModule(this.audioWorkletUrl);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t\"ERROR: AudioEngine:loadWorkletProcessorCode: AudioWorklet not supported in this browser: \",\n\t\t\t\t\terr.message\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t// Custom node constructor with required parameters\n\t\t\t\tthis.audioWorkletNode = new CustomMaxiNode(\n\t\t\t\t\tthis.audioContext,\n\t\t\t\t\tthis.audioWorkletProcessorName\n\t\t\t\t);\n\n\t\t\t\t// All possible error event handlers subscribed\n\t\t\t\tthis.audioWorkletNode.onprocessorerror = (event) => {\n\t\t\t\t\t// Errors from the processor\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`DEBUG:AudioEngine:loadWorkletProcessorCode: MaxiProcessor Error detected`\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tthis.audioWorkletNode.port.onmessageerror = (event) => {\n\t\t\t\t\t//  error from the processor port\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`DEBUG:AudioEngine:loadWorkletProcessorCode: Error message from port: ` +\n\t\t\t\t\t\t\tevent.data\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\t// State changes in the audio worklet processor\n\t\t\t\tthis.audioWorkletNode.onprocessorstatechange = (event) => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`DEBUG:AudioEngine:loadWorkletProcessorCode: MaxiProcessor state change detected: ` +\n\t\t\t\t\t\t\taudioWorkletNode.processorState\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\t// Worklet Processor message handler\n\t\t\t\tthis.audioWorkletNode.port.onmessage = (event) => {\n\t\t\t\t\tthis.onProcessorMessageEventHandler(event);\n\t\t\t\t};\n\n\t\t\t\treturn true;\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t\"ERROR: AudioEngine:loadWorkletProcessorCode: Custom AudioWorklet node creation: \",\n\t\t\t\t\terr.message\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tloadSample(objectName, url) {\n\t\tif (this.audioContext !== undefined) {\n\t\t\tloadSampleToArray(\n\t\t\t\tthis.audioContext,\n\t\t\t\tobjectName,\n\t\t\t\turl,\n\t\t\t\tthis.audioWorkletNode\n\t\t\t);\n\t\t} else throw \"Audio Context is not initialised!\";\n\t}\n}\n\nexport { AudioEngine };"],"names":["RingBuffer","[object Object]","capacity","type","BYTES_PER_ELEMENT","bytes","SharedArrayBuffer","sab","ArrayBuffer","__proto__","isPrototypeOf","undefined","this","_type","byteLength","buf","write_ptr","Uint32Array","read_ptr","storage","name","elements","rd","Atomics","load","wr","_storage_capacity","to_write","Math","min","_available_write","length","first_part","second_part","_copy","store","to_read","_available_read","rv","input","offset_input","output","offset_output","size","i","_keyStr","removePaddingFromBase64","Module","maxiTools","indexOf","charAt","substring","CustomMaxiNode","AudioWorkletNode","audioContext","processorName","console","log","super","numberOfInputs","numberOfOutputs","outputChannelCount","destination","maxChannelCount","AudioEngine","instance","analysers","sharedArrayBuffers","event","data","rq","ttype","messaging","publish","value","ch","peerNet","send","channelID","blocksize","phase","audioWorkletNode","port","postMessage","analyser","timeDataArray","Uint8Array","fftSize","frequencyDataArray","getByteTimeDomainData","getByteFrequencyData","smoothingTimeConstant","analyserID","callback","createAnalyser","minDecibels","maxDecibels","connect","analyserFrameId","analyserData","analyserPollingLoop","pollAnalyserData","requestAnimationFrame","Object","keys","map","id","cancelAnimationFrame","chID","getStorageForCapacity","Float64Array","ringbuf","func","rb","audioWorkletURL","audioWorkletProcessorName","audioWorkletUrl","samplesLoaded","AudioContext","latencyHint","channelInterpretation","channelCountMode","channelCount","loadWorkletProcessorCode","createSharedArrayBuffer","state","stop","resume","suspend","disconnect","gain","gainParam","parameters","get","dspFunction","eval","setup","loop","idx","stream","createMediaStreamSource","error","message","constraints","window","audio","video","navigator","mediaDevices","getUserMedia","then","s","onAudioInputInit","catch","onAudioInputFail","audioWorklet","addModule","err","onprocessorerror","onmessageerror","onprocessorstatechange","processorState","onmessage","onProcessorMessageEventHandler","objectName","url","sampleObjectName","b64","str","dataStart","slice","match","getBase64","ab_bytes","arrayBuffer","uarray","chr1","chr2","chr3","enc2","enc3","enc4","parseInt","j","replace","decodeAudioData","buffer","float32ArrayBuffer","getChannelData","sample","request","XMLHttpRequest","addEventListener","open","responseType","onload","response","loadSampleToArray"],"mappings":"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"}